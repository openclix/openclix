{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://openclix.ai/schemas/openclix.schema.json",
  "title": "OpenClix",
  "description": "On-device campaign and messaging schema for OpenClix. Defines config (remote campaign definitions), message queue (scheduled messages in device storage), and events (tracked event log).",
  "type": "object",
  "$ref": "#/$defs/config",
  "$defs": {
    "config": {
      "type": "object",
      "description": "Remote campaign configuration fetched from a URL. Defines campaign rules and message templates.",
      "additionalProperties": false,
      "required": [
        "schema_version",
        "config_version",
        "campaigns"
      ],
      "properties": {
        "schema_version": {
          "type": "string",
          "const": "openclix/config/v1",
          "description": "Schema contract version. The SDK uses this value to select the correct parser.",
          "examples": [
            "openclix/config/v1"
          ]
        },
        "config_version": {
          "type": "string",
          "minLength": 1,
          "description": "Config payload version for cache invalidation and change detection. Can be semver, revision ID, or etag.",
          "examples": [
            "1.0.0",
            "rev-2024-01-15-abc"
          ]
        },
        "settings": {
          "$ref": "#/$defs/settings",
          "description": "Global SDK settings that apply across all campaigns."
        },
        "campaigns": {
          "type": "object",
          "description": "Map of campaign ID to campaign definition. Keys must be kebab-case identifiers.",
          "propertyNames": {
            "pattern": "^[a-z0-9]+(-[a-z0-9]+)*$"
          },
          "additionalProperties": {
            "$ref": "#/$defs/campaign"
          },
          "minProperties": 1
        }
      }
    },
    "settings": {
      "type": "object",
      "description": "Global SDK settings that apply across all campaigns.",
      "additionalProperties": false,
      "properties": {
        "frequency_cap": {
          "$ref": "#/$defs/frequency_cap",
          "description": "Limits the maximum number of messages a user can receive within a rolling time window."
        },
        "do_not_disturb": {
          "$ref": "#/$defs/do_not_disturb",
          "description": "Time window during which message delivery is suppressed."
        }
      }
    },
    "frequency_cap": {
      "type": "object",
      "description": "Limits the maximum number of messages delivered to a user within a rolling time window.",
      "additionalProperties": false,
      "required": [
        "max_count",
        "window_seconds"
      ],
      "properties": {
        "max_count": {
          "type": "integer",
          "minimum": 1,
          "description": "Maximum number of messages a user can receive within the window.",
          "examples": [
            3,
            5
          ]
        },
        "window_seconds": {
          "type": "integer",
          "minimum": 1,
          "description": "Rolling time window in seconds.",
          "examples": [
            86400,
            3600
          ]
        }
      }
    },
    "do_not_disturb": {
      "type": "object",
      "description": "Time window during which message delivery is suppressed. Messages scheduled during this period are skipped.",
      "additionalProperties": false,
      "required": [
        "start_hour",
        "end_hour"
      ],
      "properties": {
        "start_hour": {
          "type": "integer",
          "minimum": 0,
          "maximum": 23,
          "description": "Start hour (inclusive) in 24-hour format, interpreted in device local time.",
          "examples": [
            22
          ]
        },
        "end_hour": {
          "type": "integer",
          "minimum": 0,
          "maximum": 23,
          "description": "End hour (exclusive) in 24-hour format. When end_hour < start_hour, the window wraps past midnight (e.g., 22-8 means 22:00 to 07:59).",
          "examples": [
            8
          ]
        }
      }
    },
    "campaign": {
      "type": "object",
      "description": "A single campaign definition. Each campaign delivers one message when its trigger conditions are met.",
      "additionalProperties": false,
      "required": [
        "name",
        "type",
        "description",
        "status",
        "trigger",
        "message"
      ],
      "properties": {
        "name": {
          "type": "string",
          "minLength": 1,
          "description": "Human-readable campaign name for dashboards and debugging."
        },
        "type": {
          "type": "string",
          "const": "campaign",
          "description": "Campaign type discriminator.",
          "examples": [
            "campaign"
          ]
        },
        "description": {
          "type": "string",
          "minLength": 1,
          "description": "Human-readable description of the campaign's purpose."
        },
        "status": {
          "$ref": "#/$defs/campaign_status",
          "description": "Current operational status of the campaign."
        },
        "trigger": {
          "$ref": "#/$defs/campaign_trigger",
          "description": "Defines how and when this campaign is triggered."
        },
        "message": {
          "$ref": "#/$defs/message",
          "description": "The single message delivered by this campaign."
        }
      }
    },
    "campaign_status": {
      "type": "string",
      "enum": [
        "running",
        "paused"
      ],
      "description": "'running' = live and accepting new enrollments. 'paused' = temporarily suspended."
    },
    "campaign_trigger": {
      "type": "object",
      "description": "Trigger configuration for a campaign.",
      "additionalProperties": false,
      "required": [
        "type"
      ],
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "event",
            "scheduled",
            "recurring"
          ],
          "description": "Trigger mechanism type."
        },
        "event": {
          "$ref": "#/$defs/event_trigger_config",
          "description": "Event-based trigger configuration. Required when type is 'event'."
        },
        "scheduled": {
          "$ref": "#/$defs/scheduled_trigger_config",
          "description": "Scheduled trigger configuration. Required when type is 'scheduled'."
        },
        "recurring": {
          "$ref": "#/$defs/recurring_trigger_config",
          "description": "Recurring trigger configuration. Required when type is 'recurring'."
        }
      },
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "event"
              }
            },
            "required": [
              "type"
            ]
          },
          "then": {
            "required": [
              "event"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "scheduled"
              }
            },
            "required": [
              "type"
            ]
          },
          "then": {
            "required": [
              "scheduled"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "type": {
                "const": "recurring"
              }
            },
            "required": [
              "type"
            ]
          },
          "then": {
            "required": [
              "recurring"
            ]
          }
        }
      ]
    },
    "event_trigger_config": {
      "type": "object",
      "description": "Configuration for event-based campaign triggers.",
      "additionalProperties": false,
      "required": [
        "trigger_event"
      ],
      "properties": {
        "trigger_event": {
          "$ref": "#/$defs/event_condition_group",
          "description": "Event conditions that must be satisfied to trigger the campaign."
        },
        "delay_seconds": {
          "type": "integer",
          "minimum": 0,
          "description": "Delay in seconds after the trigger event before enrollment is confirmed. During this period, cancel_event conditions are evaluated."
        },
        "cancel_event": {
          "$ref": "#/$defs/event_condition_group",
          "description": "Event conditions that cancel a pending trigger during the delay period."
        }
      }
    },
    "scheduled_trigger_config": {
      "type": "object",
      "description": "Configuration for one-time scheduled campaign triggers.",
      "additionalProperties": false,
      "required": [
        "execute_at"
      ],
      "properties": {
        "execute_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp at which the campaign should trigger once."
        }
      }
    },
    "recurring_trigger_config": {
      "type": "object",
      "description": "Configuration for recurring campaign triggers.",
      "additionalProperties": false,
      "required": [
        "rule"
      ],
      "properties": {
        "start_at": {
          "type": "string",
          "format": "date-time",
          "description": "Optional ISO 8601 start time. If omitted, SDK runtime anchor is used."
        },
        "end_at": {
          "type": "string",
          "format": "date-time",
          "description": "Optional ISO 8601 end time. Recurrence stops after this time."
        },
        "rule": {
          "$ref": "#/$defs/recurrence_rule",
          "description": "Recurrence rule configuration."
        }
      }
    },
    "recurrence_rule": {
      "type": "object",
      "description": "Rule definition for recurring triggers.",
      "additionalProperties": false,
      "required": [
        "type",
        "interval"
      ],
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "hourly",
            "daily",
            "weekly"
          ],
          "description": "Recurrence frequency."
        },
        "interval": {
          "type": "integer",
          "minimum": 1,
          "description": "Repeat interval for the selected recurrence type."
        },
        "weekly_rule": {
          "$ref": "#/$defs/weekly_rule",
          "description": "Weekly recurrence detail. Required when recurrence type is 'weekly'."
        },
        "time_of_day": {
          "$ref": "#/$defs/time_of_day",
          "description": "Optional target delivery time in local device time."
        }
      },
      "allOf": [
        {
          "if": {
            "properties": {
              "type": {
                "const": "weekly"
              }
            },
            "required": [
              "type"
            ]
          },
          "then": {
            "required": [
              "weekly_rule"
            ]
          }
        }
      ]
    },
    "weekly_rule": {
      "type": "object",
      "description": "Weekly recurrence details.",
      "additionalProperties": false,
      "required": [
        "days_of_week"
      ],
      "properties": {
        "days_of_week": {
          "type": "array",
          "minItems": 1,
          "uniqueItems": true,
          "items": {
            "type": "string",
            "enum": [
              "sunday",
              "monday",
              "tuesday",
              "wednesday",
              "thursday",
              "friday",
              "saturday"
            ]
          },
          "description": "Days of week when recurrence is eligible."
        }
      }
    },
    "time_of_day": {
      "type": "object",
      "description": "Local time-of-day values for recurring schedules.",
      "additionalProperties": false,
      "required": [
        "hour",
        "minute"
      ],
      "properties": {
        "hour": {
          "type": "integer",
          "minimum": 0,
          "maximum": 23
        },
        "minute": {
          "type": "integer",
          "minimum": 0,
          "maximum": 59
        }
      }
    },
    "event_condition_group": {
      "type": "object",
      "description": "A group of event conditions joined by a logical connector.",
      "additionalProperties": false,
      "required": [
        "connector",
        "conditions"
      ],
      "properties": {
        "connector": {
          "type": "string",
          "enum": [
            "and",
            "or"
          ],
          "description": "Logical connector between conditions."
        },
        "conditions": {
          "type": "array",
          "minItems": 1,
          "items": {
            "$ref": "#/$defs/event_condition_rule"
          },
          "description": "List of event condition rules to evaluate."
        }
      }
    },
    "event_condition_rule": {
      "type": "object",
      "description": "A single event condition rule.",
      "additionalProperties": false,
      "required": [
        "field",
        "operator",
        "values"
      ],
      "properties": {
        "field": {
          "type": "string",
          "enum": [
            "name",
            "property"
          ],
          "description": "The event field to evaluate. 'name' matches the event name. 'property' matches a specific event property (requires property_name)."
        },
        "property_name": {
          "type": "string",
          "minLength": 1,
          "description": "The event property key to evaluate. Required when field is 'property'."
        },
        "operator": {
          "$ref": "#/$defs/event_condition_operator",
          "description": "Comparison operator to apply."
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Values to compare against. All values are strings; the SDK casts as needed."
        }
      },
      "allOf": [
        {
          "if": {
            "properties": {
              "field": {
                "const": "property"
              }
            },
            "required": [
              "field"
            ]
          },
          "then": {
            "required": [
              "property_name"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "operator": {
                "enum": [
                  "exists",
                  "not_exists"
                ]
              }
            },
            "required": [
              "operator"
            ]
          },
          "then": {
            "properties": {
              "values": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          },
          "else": {
            "properties": {
              "values": {
                "type": "array",
                "minItems": 1,
                "items": {
                  "type": "string"
                }
              }
            }
          }
        }
      ]
    },
    "event_condition_operator": {
      "type": "string",
      "enum": [
        "equal",
        "not_equal",
        "greater_than",
        "greater_than_or_equal",
        "less_than",
        "less_than_or_equal",
        "contains",
        "not_contains",
        "starts_with",
        "ends_with",
        "matches",
        "exists",
        "not_exists",
        "in",
        "not_in"
      ],
      "description": "Comparison operators for event condition rules."
    },
    "message": {
      "type": "object",
      "description": "The single message template delivered by a campaign.",
      "additionalProperties": false,
      "required": [
        "channel_type",
        "content"
      ],
      "properties": {
        "channel_type": {
          "type": "string",
          "enum": [
            "app_push"
          ],
          "description": "Delivery channel. 'app_push' = local notification via OS. 'in_app' = in-app message overlay (SDK waits for foreground automatically)."
        },
        "content": {
          "$ref": "#/$defs/message_content",
          "description": "The notification or in-app message content."
        }
      }
    },
    "message_content": {
      "type": "object",
      "description": "Content payload for a notification or in-app message. Supports {{key}} template syntax in title and body, resolved from the trigger event payload at delivery time.",
      "additionalProperties": false,
      "required": [
        "title",
        "body"
      ],
      "properties": {
        "title": {
          "type": "string",
          "minLength": 1,
          "maxLength": 120,
          "description": "Notification title. Supports {{key}} template variables."
        },
        "body": {
          "type": "string",
          "minLength": 1,
          "maxLength": 500,
          "description": "Notification body text. Supports {{key}} template variables."
        },
        "image_url": {
          "type": "string",
          "format": "uri",
          "description": "Optional image URL for rich notifications."
        },
        "landing_url": {
          "type": "string",
          "format": "uri-reference",
          "description": "URL or deep link to navigate to when the user taps the notification. If omitted, tapping opens the app's default screen."
        }
      }
    },
    "queued_message": {
      "type": "object",
      "description": "A message record in the device-local delivery queue. Created when a campaign triggers, consumed and deleted when execute_at is reached.",
      "additionalProperties": false,
      "required": [
        "id",
        "campaign_id",
        "channel_type",
        "status",
        "content",
        "execute_at",
        "created_at"
      ],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique scheduled message identifier."
        },
        "campaign_id": {
          "type": "string",
          "description": "The campaign that produced this message."
        },
        "channel_type": {
          "type": "string",
          "enum": [
            "app_push"
          ],
          "description": "Delivery channel for this message."
        },
        "status": {
          "$ref": "#/$defs/queued_message_status",
          "description": "Current lifecycle status of this scheduled message."
        },
        "content": {
          "type": "object",
          "description": "Resolved message content with template variables substituted from the trigger event payload.",
          "additionalProperties": false,
          "required": [
            "title",
            "body"
          ],
          "properties": {
            "title": {
              "type": "string",
              "description": "Resolved notification title."
            },
            "body": {
              "type": "string",
              "description": "Resolved notification body."
            },
            "image_url": {
              "type": "string",
              "format": "uri",
              "description": "Image URL for rich notifications."
            },
            "landing_url": {
              "type": "string",
              "format": "uri-reference",
              "description": "URL or deep link opened when the user taps the notification."
            }
          }
        },
        "trigger_event_id": {
          "type": "string",
          "description": "The ID of the event that triggered this message. Used for traceability."
        },
        "skip_reason": {
          "$ref": "#/$defs/skip_reason",
          "description": "Reason why this message was skipped or cancelled. Present only when status is 'skipped' or 'cancelled'."
        },
        "execute_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp at which this message should be delivered. Calculated as trigger_time + delay_seconds."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp of when this record was created."
        }
      }
    },
    "queued_message_status": {
      "type": "string",
      "enum": [
        "scheduled",
        "delivered",
        "cancelled"
      ],
      "description": "'scheduled' = waiting for execute_at. 'delivered' = in-app message presented or local notification handed off to OS. 'cancelled' = cancelled before delivery (cancel_conditions met or cancel_event matched)."
    },
    "skip_reason": {
      "type": "string",
      "enum": [
        "campaign_not_running",
        "campaign_frequency_cap_exceeded",
        "campaign_do_not_disturb_blocked",
        "trigger_event_not_matched",
        "trigger_cancel_event_matched"
      ],
      "description": "Reason why a campaign was not triggered or a queued message was cancelled. 'campaign_not_running' = campaign status is not 'running'. 'campaign_frequency_cap_exceeded' = settings.frequency_cap limit exceeded. 'campaign_do_not_disturb_blocked' = message execute_at falls within settings.do_not_disturb window. 'trigger_event_not_matched' = trigger.event.trigger_event conditions did not match. 'trigger_cancel_event_matched' = trigger.event.cancel_event matched during the delay period."
    },
    "campaign_state_snapshot": {
      "type": "object",
      "description": "Flat campaign-state snapshot persisted on device.",
      "additionalProperties": false,
      "required": [
        "campaign_states",
        "queued_messages",
        "trigger_history",
        "updated_at"
      ],
      "properties": {
        "campaign_states": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/campaign_state_record"
          }
        },
        "queued_messages": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/campaign_queued_message"
          }
        },
        "trigger_history": {
          "type": "array",
          "items": {
            "$ref": "#/$defs/campaign_trigger_history"
          }
        },
        "updated_at": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "campaign_state_record": {
      "type": "object",
      "description": "Flat campaign state row.",
      "additionalProperties": false,
      "required": [
        "campaign_id",
        "triggered",
        "delivery_count"
      ],
      "properties": {
        "campaign_id": {
          "type": "string"
        },
        "triggered": {
          "type": "boolean"
        },
        "delivery_count": {
          "type": "integer",
          "minimum": 0
        },
        "last_triggered_at": {
          "type": "string",
          "format": "date-time"
        },
        "recurring_anchor_at": {
          "type": "string",
          "format": "date-time"
        },
        "recurring_last_scheduled_at": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "campaign_queued_message": {
      "type": "object",
      "description": "Flat queued-message row within campaign state snapshot.",
      "additionalProperties": false,
      "required": [
        "message_id",
        "campaign_id",
        "execute_at",
        "trigger_type",
        "created_at"
      ],
      "properties": {
        "message_id": {
          "type": "string"
        },
        "campaign_id": {
          "type": "string"
        },
        "execute_at": {
          "type": "string",
          "format": "date-time"
        },
        "trigger_type": {
          "type": "string",
          "enum": [
            "event",
            "scheduled",
            "recurring"
          ]
        },
        "trigger_event_id": {
          "type": "string"
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "campaign_trigger_history": {
      "type": "object",
      "description": "Flat trigger-history row for frequency-cap checks.",
      "additionalProperties": false,
      "required": [
        "triggered_at"
      ],
      "properties": {
        "campaign_id": {
          "type": "string"
        },
        "triggered_at": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "event": {
      "type": "object",
      "description": "A tracked event record in the on-device event store. Covers both app events and system events.",
      "additionalProperties": false,
      "required": [
        "id",
        "name",
        "source_type",
        "created_at"
      ],
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique event record identifier."
        },
        "name": {
          "type": "string",
          "description": "Event name. For app events, use app-defined names. For system events, must be a value from system_event_name.",
          "examples": [
            "cart_abandon",
            "purchase_completed",
            "clix.message.delivered"
          ]
        },
        "source_type": {
          "type": "string",
          "enum": [
            "app",
            "system"
          ],
          "description": "'app' = event tracked by the app via SDK. 'system' = event emitted by the OpenClix engine."
        },
        "properties": {
          "type": "object",
          "description": "Event payload. For app events, app-defined properties. For system events, structured fields (campaign_id, queued_message_id, channel_type, skip_reason, failure_reason, etc.).",
          "additionalProperties": true
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "description": "ISO 8601 timestamp of when the event occurred."
        }
      }
    },
    "system_event_name": {
      "type": "string",
      "enum": [
        "clix.message.scheduled",
        "clix.message.delivered",
        "clix.message.opened",
        "clix.message.cancelled",
        "clix.message.failed"
      ],
      "description": "System event names emitted by the OpenClix engine. Naming convention: clix.message.<action>. 'clix.message.scheduled' = campaign triggered and message added to delivery queue (properties: campaign_id, queued_message_id, channel_type, execute_at). 'clix.message.delivered' = in-app message presented or local notification handed off to OS (properties: campaign_id, queued_message_id, channel_type). 'clix.message.opened' = user tapped the notification (properties: campaign_id, queued_message_id, channel_type). 'clix.message.cancelled' = message cancelled before delivery (properties: campaign_id, queued_message_id, skip_reason). 'clix.message.failed' = message delivery failed (properties: campaign_id, queued_message_id, channel_type, failure_reason)."
    }
  }
}
